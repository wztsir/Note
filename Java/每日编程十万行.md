# 每日编程十万行

## 22.02.26

```java
 /**
     加密数据的简单功能
     */
    public static void main(String[] args) {
        Scanner sr = new Scanner(System.in);
        System.out.println("请输入要加密几位数字");
        int number = sr.nextInt();
        int[] arr = new int[number];
        Random r = new Random();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = r.nextInt(10);
        }
        System.out.println("原数据为");
        printArray(arr);
//        1、数据简单处理
        for (int i = 0; i < number; i++) {

            arr[i] = (arr[i] + 5) % 10;
        }
//        2、数组翻转
        for (int i = 0, j = arr.length - 1; i < j; i++, j--) {
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        System.out.println("加密后的数据为");
        printArray(arr);
    }

    public static void printArray(int[] arr) {
        System.out.print("[");
        for (int i = 0; i < arr.length; i++) {
            System.out.print(i==arr.length-1?arr[i]:arr[i]+",");
        }
        System.out.println("]");
    }

//简单验证码
public static void main(String[] args) {
        String datas="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        System.out.println(datas.length());
        String code="";
        Random r=new Random();
        for (int i = 0; i < 5; i++) {
           int index=r.nextInt(datas.length());
            System.out.println(index);
            code+=datas.charAt(index);
        }
        System.out.println(code);
    }

//手机号加密
public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入手机号");
        String tel = sc.next();
        String temp = tel.substring(3, 7);
        System.out.println(tel.replace(temp, "****"));
    }

//验证登入
 public static void main(String[] args) {
        String okLoginName = "wztishandsome";
        String okPassword = "15914428221";
        //只能登入三次
        Scanner sc = new Scanner(System.in);
        for (int i = 0; i < 3; i++) {
            System.out.println("请输入登入账号");
            String loginName = sc.next();
            System.out.println("请输入登入密码");
            String loginPassword = sc.next();

            if (okLoginName.equals(loginName)) {
                if (okPassword.equals(loginPassword)) {
                    System.out.println("登入成功！");
                    break;
                } else {
                    System.out.println("您的密码不正确！还有" + (2 - i) + "次机会");
                }
            } else {
                System.out.println("您的账号不正确！还有" + (2 - i) + "次机会");
            }
        }
    }

//倒序删除元素
public static void main(String[] args) {
        ArrayList<Integer> al=new ArrayList<>();
        Random r=new Random();
        for (int i = 0; i < 10; i++) {
            al.add(r.nextInt(101));
        }
        System.out.println(al);
        for (int i = al.size()-1; i >=0 ; i--) {
            int temp=al.get(i);
            if(temp<80)al.remove(i);
        }
        System.out.println(al);
    }
```

## 22.02.27

```java
//验证static
public class User {
        public static int onLineNumber=0;//初始化,如果没有手动初始化，static变量默认为该数据类型下的默认值
        private String name;
        private int age=30;

        public static void main(String[] args) {
                User.onLineNumber++;
                System.out.println(onLineNumber++);//访问权限
                User u1=new User();
                u1.name="wzt";
                u1.age=20;
                System.out.println(u1.name);
                System.out.println(u1.age);
                u1.onLineNumber++;//并不欢迎这样使用
                System.out.println(onLineNumber);
        }
}
class Good{
        public static void main(String[] args) {
//               没有 onLineNumber的访问权限
        }
}

public class test02 {
    private String name;
    public void study() {
        System.out.println(name + "在卷");
    }
    public static int getMax(int a, int b) {
        return Math.max(a, b);
//        name="wzt";不可以访问类内的需要实例化的成员变量，原因参照内存
    }

    public static void main(String[] args) {
//      1、访问
//      同时属于类与对象
        System.out.println(test02.getMax(10,2));
        System.out.println(getMax(30,2));//同类访问可以省略
//      2、对象.实例成员方法
        test02 s=new test02();
        s.name="wzt";
        s.study();
    }
}
public class ArrayUtils {
    private ArrayUtils() {
    }
    public static String toString(int[] arr) {
        String result = "[";
        for (int i = 0; i < arr.length; i++) {
            result +=(i == arr.length - 1 ? arr[i]+"]": arr[i] + "，");
        }
        return result;
    }
}
public class test03 {
    public static void main(String[] args) {
        int[] arr=new int[]{1,2,3};
        System.out.println(ArrayUtils.toString(arr));
    }
}
```

## 22.02.28

```java
 public static ArrayList<String> cards = new ArrayList<>();
//   随着类的加载而自动执行一次
    static {
        String[] colors = {"♠ ", "♥", "♣", "♦"};
        String[] sizes = {"3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"};
        for (int i = 0; i < sizes.length; i++) {
            for (int j = 0; j < colors.length; j++) {
                cards.add(sizes[i] + colors[j]);
            }
        }
        cards.add("小🃏");
        cards.add("大🃏");
    }
    public static void main(String[] args) {
        System.out.println("欢迎来到斗地主" + cards);
        System.out.println(cards.size());
    }

/**
验证单例
*/        
public class SingleInstance1 {
    public static SingleInstance1 Instance=new SingleInstance1();
//私有化构造器
    private SingleInstance1() {
    }
}
public class test05 {
    public static void main(String[] args) {
        SingleInstance1 s1 = SingleInstance1.Instance;
        SingleInstance1 s2 = SingleInstance1.Instance;
        System.out.println(s1 == s2);
//      构造器私有化不能再次实例化对象
//      SingleInstance1 s3=new SingleInstance1();
    }
}
public class SingleInstance2 {
//    私有化，必须通过getInstance得到
   private static SingleInstance2 Instance;
//    构造器私有
    private SingleInstance2(){
    }
//    暴露对象
    public static SingleInstance2 getInstance(){
        if(Instance==null){
         Instance=new SingleInstance2();
        }
        return Instance;
    }
}
```

## 22.03.30

定位

```css
.banner{
    width:520px;
    height:304px;
    /* border:1px solid; */
    margin: 1em auto;

    /* 将溢出的图片隐藏 */
    overflow: hidden;

    /* 左右大于小于的包含快 */
    position: relative;

}

/* 必须设置宽度，浮动元素才不会被动换行 */
/* 超过了banner的宽度，默认情况下overflow是显示的 */
.banner .imgs{
    width:1560px;
    height:304px;

}

/* 犯下低级错误，类选择器才要加  .<filename>   元素选择器不要加.*/
.banner .imgs img{
    width:520px;
    height:304px;
    background-color: lightblue;

    /*之后使用js实现图片切换，直接设置第一张图片使用margin-left:-520px */
}

/* .banner .imgs  .first{
    margin-left: -1040px;
} */

/* 左浮动，变成块盒，行盒之间存在空白折叠 */
.banner .imgs a{
    float: left;
}

/* 分组，两个同时设置样式 */
/* 设置成决定定位后，子元素只会相对于包含块排列，同兄弟元素层叠 */
.banner .left, .banner .right{
    position: absolute;    
    width:50px;
    height: 50px;

    /* 左右距离为0，设置自动，会在高度居中 */
    top:0;
    bottom:0;
    margin: auto;

    /* 设置字体,设置成图标会更好 */
    color: #fff;
    font-size: 3em;
    text-align: center;/*水平居中*/
    line-height: 50px;/*垂直居中*/
    font-family:Arial;

    border-radius: 50%;
    cursor: pointer;
}

.banner .left:hover,.banner .right:hover{
    background-color: #fff;
    color: #f40;
}


/* 鼠标移动时的效果 */
.banner .left{
    left:20px;
}

.banner .right{
    right:20px;
}

/* bordertop与图片的渐变显示现在未实现 */
.banner .modal{
    /* 相对于bannner */
    position: absolute;

    /* 默认是那内容区域，width==包含块的宽度，即内容块的宽度默认不变 */
    width: 100%;
    height: 40px;
    background:rgba(0,0,0,0.3);
    /*默认在底部，由于overflow：hidden,未展示
     left: 0;
    bottom: 0; */

    left: 0;
    bottom: 0;

    /* 设置文字 */
    line-height: 40px;
    color: #fff;

    /* 要求内+内外边距==包含块宽度，右边距变为负数*/
    padding:0 20px;

    box-sizing: border-box;
}

.banner .modal .title{
    float:left;
    font-weight: bolder;
}

.banner .modal .dots{
    float:right;
}
/* 从上到下依次排列，浮动 */
.banner .modal .dots li{
    width:8px;
    height: 8px;
    background:#ccc;

    border-radius: 50px;
    cursor: pointer;

    /* 行块盒 */
   display: inline-block;
   margin:0 2px;
}

.banner .modal .dots li:hover{
    background: #369;
}
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="./css/reset.css">
    <link rel="stylesheet" href="./css/轮播图.css">
</head>
<body>

    <div class="banner">
        <div class="imgs">
            <!-- 图片横向排列，依次放置 -->
            <a href=""><img class="first" src="./img/1.jpg" alt=""></a>
            <a href=""><img src="./img/2.jpg" alt=""></a>
            <a href=""><img src="./img/3.jpg" alt=""></a>
        </div>
        <!-- 箭头 -->
        <div class="left"><</div>
        <div class="right">></div>
        <!-- 朦层，展现文字 -->
        <div class="modal">
            <div class="title">
                广州塔欢迎你
            </div>
            <div class="dots">
                <ul>
                    <li></li>
                    <li></li>
                    <li></li>
                </ul>
            </div>
        </div>
    </div>

</body>
</html>
```

## 22.04.05

```css
/* 设置消除浮动，写在最上面，解决所有的浮动坍塌问题 */
.clearfix::after{
    content: "";
    display: block;
    clear: both;
}

.main{
    line-height: 1.5;
}

.main .nav{
    height: 60px;
    line-height: 60px;
    color:#999;
    text-align:center;

    background: #47464a;
}

.main .nav a{
    /*行盒设置水平边距 */
    margin: 0 38px;
}
.main .nav a:hover{
    color: #fff;
}

/* 写元素叠加类选择器时， a.select  .之间没有空格 */
/* 并且a不能去除，同.main .nav a:hover比较特殊性 */
.main .nav a.select{
    color:#ef4638;
}

.main .container{
    width:1120px;
    /* height:500px; 不应该设置高度，应该由内容撑开*/
    margin:0 auto;

}

.main .container .choose-area{
    border: 1px solid #e5e5e5;
    margin:40px 0;

    /* 设置所有文字的行高，使不同块的文字同行对其 */
    line-height: 40px;

    /* 实现左右内容同边框的距离 */
    padding:30px;
}

.main .container .choose-area .choose-item{
    margin:1em 0;
    border-bottom: 1px dotted #e5e5e5;
}

/* .choose-item.no-line必须连着写，表示兄弟，并列；  有空格的表示父子关系 */
.main .container .choose-area .choose-item.no-line{
    border:none;
}

.main .container .choose-area .choose-item .left{
        float:left;
        /* width:60px;

         /* 文字靠右，实现左边距的效果 
         text-align: right; */

        color:#999;
}

.main .container .choose-area .choose-item .right{
    float: left;
    /* background: red; */
    /* border:2px solid #ccc; */

    /* 必须设置宽度，默认被内容撑开，无法同文字《类型》并行 */
    width:1010px;

}

.main .container .choose-area .choose-item .right li{
    /* 设置为左浮动，可以并行展示元素 */
    float:left;
    margin:0 9px;

    /* 没有设置宽高，适应内容 ，同块盒一致*/
    /* width:100px;
    height:50px;
    background: red;
    border:2px solid black;*/

    padding:0 6px;
} 

.main .container .choose-area .choose-item .right li:hover{
    color:#ef4238;
}

.main .container .choose-area .choose-item .right li.select{
    background: red;
    /* radius为圆半径的长度 */
    border-radius: 15px;
    color: lightblue;
}
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>猫眼电影</title>
    <link rel="stylesheet" href="./css/reset.css">
    <link rel="stylesheet" href="./css/movie.css">
</head>

<body>
    <div class="main">
        <nav class="nav">
            <a href="" class="select">Lorem.</a>
            <a href="">Neque!</a>
            <a href="">Cumque?</a>
        </nav>

        <div class="container">
            <div class="choose-area">
                <div class="choose-item clearfix">
                    <!-- 设置成浮动，设置同级元素 ，消除浮动，利用伪类，即在父亲设置 -->
                    <div class="left">类型：</div>
                    <div class="right">
                        <ul>
                            <li class="select">Lorem.</li>
                            <li>Maiores?</li>
                            <li>Ut?</li>
                            <li>Doloribus!</li>
                            <li>Dolore.</li>
                            <li>Repellat!</li>
                            <li>Aperiam.</li>
                            <li>Quibusdam.</li>
                            <li>Dolorum.</li>
                            <li>Dolor?</li>
                            <li>Architecto.</li>
                            <li>Animi!</li>
                            <li>Expedita!</li>
                            <li>Quo?</li>
                            <li>Rerum.</li>
                            <li>Facilis.</li>
                            <li>Cum!</li>
                            <li>Id?</li>
                            <li>Inventore.</li>
                            <li>Harum!</li>
                        </ul>
                    </div>

                </div>
                <div class="choose-item clearfix">
                    <div class="left">区域：</div>
                    <div class="right">
                        <ul>
                            <li>Lorem.</li>
                            <li>Maiores?</li>
                            <li>Ut?</li>
                            <li>Doloribus!</li>
                            <li>Dolore.</li>
                            <li>Repellat!</li>
                            <li>Aperiam.</li>
                            <li>Quibusdam.</li>
                            <li>Dolorum.</li>
                            <li>Dolor?</li>
                            <li>Architecto.</li>
                            <li>Animi!</li>
                            <li>Expedita!</li>
                            <li>Quo?</li>
                            <li>Rerum.</li>
                            <li>Facilis.</li>
                            <li>Cum!</li>
                            <li>Id?</li>
                            <li>Inventore.</li>
                            <li>Harum!</li>
                        </ul>
                    </div>

                </div>
                <div class="choose-item clearfix no-line">
                    <div class="left">年代：</div>
                    <div class="right">
                        <ul>
                            <li>Lorem.</li>
                            <li>Maiores?</li>
                            <li>Ut?</li>
                            <li>Doloribus!</li>
                            <li>Dolore.</li>
                            <li>Repellat!</li>
                            <li>Aperiam.</li>
                            <li>Quibusdam.</li>
                            <li>Dolorum.</li>
                            <li>Dolor?</li>
                            <li>Architecto.</li>
                            <li>Animi!</li>
                            <li>Expedita!</li>
                            <li>Quo?</li>
                            <li>Rerum.</li>
                            <li>Facilis.</li>
                            <li>Cum!</li>
                            <li>Id?</li>
                            <li>Inventore.</li>
                            <li>Harum!</li>
                        </ul>
                    </div>

                </div>
            </div>

            <div class="movies">
                <div class="movie-item">
                    <div class="poster">
                        <a href="">
                            <img src="./img/test.jpg" alt="">
                        </a>
                    </div>
                    <div class="name">
                        <a href="">
                            当幸福来敲门
                        </a>
                    </div>
                    <div class="score">
                        9.9
                    </div>
                </div>
            </div>

            div.movie-item*30>(div.poster>a>img[src="./img/test.jpg"])+(div.name>a>当幸福来敲门)+(div.score>{9.9})

        </div>
    </div>
</body>
</html>
```

## 22.04.18

导入数据

```sql
use mybatis;
create table tb_brand
(
-- id 主键
    id int primary key auto_increment,
-- 品牌名称
    brand_name varchar(20),
-- 企业名称
    company_name varchar(20),
-- 排序字段
    ordered int,
-- 描述信息
    description varchar(100),
-- 状态：0：禁用 1：启用
    status int
    );
-- 添加数据
insert into tb_brand (brand_name, company_name, ordered, description, status)
values ('三只松鼠', '三只松鼠股份有限公司', 5, '好吃不上火', 0),
       ('华为', '华为技术有限公司', 100, '华为致力于把数字世界带入每个人、每个家庭、每个组织，构建万物互联的智
能世界', 1),
       ('小米', '小米科技有限公司', 50, 'are you ok', 1)
```

pom.xml配置

```xml
<dependencies>
  <!-- mybatis -->
  <dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.5.5</version>
  </dependency>
  <!--mysql-->
  <dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.11</version>
  </dependency>
  <!--servlet-->
  <dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
  </dependency>
  <!--jsp-->

  <dependency>
    <groupId>javax.servlet.jsp</groupId>
    <artifactId>jsp-api</artifactId>
    <version>2.2</version>
    <scope>provided</scope>
  </dependency>
  <!--jstl-->
  <dependency>
    <groupId>jstl</groupId>
    <artifactId>jstl</artifactId>
    <version>1.2</version>
  </dependency>
  <dependency>
    <groupId>taglibs</groupId>
    <artifactId>standard</artifactId>
    <version>1.1.2</version>
  </dependency>
</dependencies>
```

pojo包：Brand类，封装数据

```java
public class Brand {
    private Integer id;
    // 品牌名称
    private String brandName;
    // 企业名称
    private String companyName;
    // 排序字段
    private Integer ordered;
    // 描述信息
    private String description;
    // 状态：0：禁用 1：启用
    private Integer status;}
```

mybatis-config.xml

```xml
<configuration>
    <!--起别名-->
    <typeAliases>
        <!--name属性的值是实体类所在包,没什么屌用-->
        <package name="com.baseStudy.pojo"/>
    </typeAliases>

    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.jdbc.Driver"/>
            <!--&  代表and  mybatis代表连接的特定数据库名数据库-->
                <property name="url" value="jdbc:mysql:///mybatis?useSSL=false&useServerPrepStmts=true"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>


    <mappers>
        <!--扫描mapper-->
        <package name="com.baseStudy.mapper"/>
    </mappers>
</configuration>
```

mapper包：BrandMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
        <!DOCTYPE mapper
                PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--核心代码,建立映射-->
<mapper namespace="com.baseStudy.mapper.BrandMapper">
</mapper>
```

BrandMapper

```java
public interface  BrandMapper {
    @Select("select * from tb_brand")
    List<Brand> selectAll();
}
```

工具类SqlSessionFactoryUtils

```java
public class SqlSessionFactoryUtils {

    private static SqlSessionFactory sqlSessionFactory;
    static {
//静态代码块会随着类的加载而自动执行，且只执行一次
        try {
            String resource = "mybatis-config.xml";
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static SqlSessionFactory getSqlSessionFactory(){
        return sqlSessionFactory;
    }
}
```

service包：BrandService

```java
public class BrandService {
    SqlSessionFactory factory = SqlSessionFactoryUtils.getSqlSessionFactory();
    public List<Brand> selectAll(){
        SqlSession sqlSession = factory.openSession();
        BrandMapper mapper = sqlSession.getMapper(BrandMapper.class);
        List<Brand> brands = mapper.selectAll();
        sqlSession.close();
        return brands;
    }
}
```

web包：selectAllServlet

```java
@WebServlet( "/selectAllServlet")
public class selectAllServlet extends HttpServlet {
  private BrandService service=new BrandService();
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
//     1、调用BrandService
        List<Brand> brands = service.selectAll();
        request.setAttribute("brands",brands);
        request.getRequestDispatcher("/brand.jsp").forward(request,response);
    }
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request,response);
    }
}
```

## 22.06.05

```java
int leftBound(int[] nums ,int target){
    int left=0;
    int right=nums.length-1;
    while (left<=right){
        int mid=(right-left)/2 +left;
        if(nums[mid]==target){
            right=mid-1;
        }
        else if(nums[mid]>target){
            right=mid-1;
        }else{
            left=mid+1;
        }
    }
    if(left>=nums.length||nums[left]!=target){
        return -1;
    }
    return left;
}
int rightBound(int[] nums,int target){
    int left=0;
    int right=nums.length-1;
    while (left<=right){
        int mid=(right-left)/2+left;
        if(nums[mid]==target){
            left=mid+1;
        }
        else if(nums[mid]<target){
            left=mid+1;
        }else{
            right=mid-1;
        }
    }
    if(right<0||nums[right]!=target)
    return -1;
    else return right;
}


//---------------------------------------------->升级
public int[] searchRange2(int[] nums, int target) {
   return new int[]{leftBound(nums, target), rightBound(nums,
           target)};
}
```

## 22.06.06

```
public int lengthOfLongestSubstring(String s) {
    if(s==null||s.length()==0)return 0;
    int right=0;
    int left=0;
    int leng=Integer.MIN_VALUE;
    Set<Character> window= new HashSet<>();
    while (right<s.length()){
        char c=s.charAt(right);
        right++;
        if(window.add(c)){
            if(right-left>leng)leng=right-left;
        }
        //如果添加失败，有重复数据
        else {
            while (window.contains(c)) {
                char l = s.charAt(left);
                left++;
                window.remove(l);
            }
            window.add(c);
        }
    }
    return leng;
}
```

## 22.06.07

```
public static boolean checkInclusion(String s1, String s2) {
    if(s2.length()<s1.length())return false;
    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();

    //      统计要相等的字符与字符数量
    for (int i = 0; i < s1.length(); i++) {
        need.put(s1.charAt(i), need.getOrDefault(s1.charAt(i), 0) + 1);

    }
    int right = 0;
    int left = 0;
    int vaild = 0;
    while (right < s1.length()) {
        char c = s2.charAt(right);
        right++;
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (need.get(c).intValue() == window.get(c).intValue()) vaild++;
            else if (window.get(c) - 1 == need.get(c)) vaild--;
        }
        if (vaild == need.size()) return true;
    }
    while (right < s2.length()) {
        char c = s2.charAt(right);
        right++;
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (need.get(c).equals(window.get(c)) ) vaild++;
            else if (window.get(c)- 1 == need.get(c)) vaild--;
        }
        char l = s2.charAt(left);
        left++;
        if (need.containsKey(l)) {
            window.put(l, window.get(l) - 1);
            if (need.get(l).intValue() == window.get(l).intValue()) vaild++;
            else if (window.get(l) + 1 == need.get(l)) vaild--;
        }
        if (vaild == need.size()) return true;
    }
    return false;
}
```

```
public  static List<Integer> findAnagrams(String s, String p) {
    List<Integer> res=new ArrayList<>();
    if(s.length()<p.length())return res;
    Map<Character, Integer> need = new HashMap<>();
    Map<Character, Integer> window = new HashMap<>();

    //      统计要相等的字符与字符数量
    for (int i = 0; i < p.length(); i++) {
        need.put(p.charAt(i), need.getOrDefault(p.charAt(i), 0) + 1);
    }

    int right = 0;
    int left = 0;

    int vaild = 0;
    while (right < p.length()) {
        char c = s.charAt(right);
        right++;
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (need.get(c).intValue() == window.get(c).intValue()) vaild++;
            else if (window.get(c) - 1 == need.get(c)) vaild--;
        }
        if (vaild == need.size()){
            res.add(0);
        }
    }
    while (right < s.length()) {
        char c = s.charAt(right);
        right++;
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (need.get(c).equals(window.get(c)) ) vaild++;
            else if (window.get(c)- 1 == need.get(c)) vaild--;
        }
        char l = s.charAt(left);
        left++;
        if (need.containsKey(l)) {
            window.put(l, window.get(l) - 1);
            if (need.get(l).intValue() == window.get(l).intValue()) vaild++;
            else if (window.get(l) + 1 == need.get(l)) vaild--;
        }
        if (vaild == need.size()) {
            res.add(left);
        }
    }

    return res;
}
```

```
public static String minWindow(String s, String t) {
        Map<Character,Integer> need=new HashMap<>();
        Map<Character,Integer> window=new HashMap<>();

//      统计要相等的字符与字符数量
        for(int i=0;i<t.length();i++){
            need.put(t.charAt(i),need.getOrDefault(t.charAt(i),0)+1);
        }
        int right=0;
        int left=0;
        int start=0;
//      vaild维护window与need字母种类一致
        int vaild=0;
        int leng=Integer.MAX_VALUE;
        while (right<s.length()){//for循环
            char c = s.charAt(right);
            right++;//如当前数据为窗口数据为0，但是right=1,所以为左开右闭
            if(need.containsKey(c)){
                window.put(c,window.getOrDefault(c,0)+1);
                if(window.get(c).intValue()==need.get(c).intValue()){
                    vaild++;
                }
            }
            System.out.println(need.size());
//         更新左指针
            while(vaild==need.size()){
                if(right-left<leng){
                    start=left;
                    leng=right-left;
                }
                char l = s.charAt(left);
                left++;
                if(need.containsKey(l)){
//                  只有当种类不一致的时候才可以减vaild
                    if(need.get(l).intValue()==window.get(l).intValue())
                        vaild--;

                    window.put(l,window.get(l)-1);
                }
            }
        }
//     窗口区间是左闭右开
        return leng==Integer.MAX_VALUE?"": s.substring(start,start+leng);
    }
```

## 22.06.08

```
 public static void flatten(TreeNode root) {
//      叶子节点直接返回，不需要处理
        if(root==null)return;
        flatten(root.left);
        flatten(root.right);
//       错误：将有子树的数据移动当前右子树的的末端
//    保存右子树
      TreeNode temp=root.right;
//      将左子树切入至右子树
        root.right=root.left;
        root.left=null;
        TreeNode p=root;
        while (p.right!=null){
            p=p.right;
        }
        p.right=temp;
    }
```

```
public Node connect(Node root) {
    if(root==null)return null;
    traverse(root.left,root.right);
    return root;
}
void traverse(Node left,Node right){
    if(left==null)return;
    left.next=right;
    traverse(left.left,left.right);
    traverse(left.right,right.left);
    traverse(right.left,right.right);
}
```

```
 public TreeNode invertTree(TreeNode root) {
     traverse(root);
     return root;
 }
void  traverse(TreeNode root){
     if(root==null)return;
     TreeNode temp=root.left;
     root.left=root.right;
     root.right=temp;
     traverse(root.left);
     traverse(root.right);
 }
```

## 22.06.09

```
  public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root =build(nums,0,nums.length-1);
        return root;
    }
// 思维过程，先是思考，根节点的逻辑，其他节点再复现，根节点的逻辑
// 注意区间是左闭右闭
    public TreeNode build (int[] nums,int left,int right){
        if(left>right)return null;
        int index=-1;
        int maxValue=Integer.MIN_VALUE;
        for(int i=left;i<=right;i++){
            if(nums[i]>maxValue){
                index=i;
                maxValue=nums[i];
            }
        }
        TreeNode root=new TreeNode(maxValue);
        root.left=build(nums,left,index-1);
        root.right=build(nums,index+1,right);
        return root;
    }
```

```
  public TreeNode buildTree(int[] preorder, int[] inorder) {
//    root=preorder [left]   3
//    left->right inorder 3
//    切分inorder，9   15，20，7
//    切分preorder,9,  20,15,17
           TreeNode root= build(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
            return root;
        }
    //  区间左闭右闭
        public TreeNode build(int[] preorder,int pleft,int pright,int[] inorder,int ileft,int iright){
            if(pleft>pright)return null;
            TreeNode root=new TreeNode(preorder[pleft]);
            int index=-1;
            for(int i=ileft;i<=iright;i++){
                if(inorder[i]==preorder[pleft])index=i;
            }
    //      统计左右树共有多少数据
            int left=index-ileft;
            int right=iright-index;
            root.left=build(preorder,pleft+1,pleft+left,inorder,ileft,ileft+left);
            root.right=build(preorder,pleft+left+1,pright,inorder,index+1,iright);
            return root;
        }
```

```
public static TreeNode   buildTree(int[] inorder, int[] postorder) {
    TreeNode root = build(postorder, 0, postorder.length - 1, inorder, 0, inorder.length - 1);
    return root;
}

//  区间左闭右闭
public  static TreeNode build(int[] postorder, int pleft, int pright, int[] inorder, int ileft, int iright) {
    if (pleft > pright) return null;
    TreeNode root = new TreeNode(postorder[pright]);
    int index = -1;
    for (int i = ileft; i <= iright; i++) {
        if (inorder[i] == postorder[pright]){
            index = i;
            break;
        }
    }
    //      统计左右树共有多少数据
    int left = index - ileft;
    int right = iright - index;
    root.left = build(postorder, pleft, pright-right-1, inorder, ileft, index-1);
    root.right = build(postorder, pright-right, pright-1, inorder, index + 1, iright);
    return root;
}
```

```
 Map<Integer,Integer> pos=new HashMap<>();
    public TreeNode constructFromPrePost(int[] preorder, int[] postorder) {
        for (int i = 0; i < postorder.length; i++) {
            pos.put(postorder[i],i);
        }
        TreeNode root = build(preorder, 0, preorder.length - 1, postorder, 0, postorder.length - 1);
        return root;
    }
    public TreeNode build(int[] preorder, int preleft,int preright,int[] postorder,int postleft,int postright){
        if(preleft>preright)return null;
//      细节的，做一层保护，必须要preleft+1才不会越界
        if(preleft==preright)return new TreeNode(preorder[preleft]);
        TreeNode root=new TreeNode(preorder[preleft]);

        int index=pos.get(preorder[preleft+1]);
//      左子树
        int left=index-postleft+1;
        root.left=build(preorder,preleft+1,preleft+left,postorder,postleft,index);
        root.right=build(preorder,preleft+left+1,preright,postorder,index+1,postright-1);

        return root;
    }
```

## 22.06.10

```
   // 代表分隔符的字符
   static String SEP = ",";
  // 代表 null 空指针的字符
   static String NULL = "#";
   // 用于拼接字符串

   static int index;
  static   StringBuilder sb = new StringBuilder();
    // Encodes a tree to a single string
    public static String serialize(TreeNode root) {
        traverse(root);
        return sb.toString();
    }
//遍历的写法,前序遍历
//  细节的数据可能是两位数，所以必须用逗号分隔
    public  static void traverse(TreeNode root){
        if(root==null){
            sb.append(NULL).append(SEP);
            return;
        }
        sb.append(root.val).append(SEP);
        traverse(root.left);
        traverse(root.right);
    }
//    输入
    //1,2,#,4,#,#,3,#,#,
    // Decodes your encoded data to tree.
    public static TreeNode deserialize(String data) {
        String[] split = data.split(",");
        index=0;
//        初始化index;
      return   build(split);

    }

    public static TreeNode build(String[] data){
        if(data[index].equals("#")) {

            index++;
            return null;
        }

        TreeNode root=new TreeNode(Integer.parseInt(data[index]));
        index++;

        root.left=build(data);
        root.right=build(data);
        return root;
    }
```

```
List<TreeNode> res = new LinkedList<>();
HashMap<String, Integer> data = new HashMap<>();
public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
    traverse(root);
    return res;
}
//  后序遍历
public String traverse(TreeNode root) {
    if (root == null) {
        return "#";
    }
    String left = traverse(root.left);
    String right = traverse(root.right);
    String temp = right + ',' + left + ',' + root.val;

    int freq = data.getOrDefault(temp, 0);
    if (freq == 1) {
        res.add(root);
    }
    data.put(temp, freq + 1);

    return temp;
}
```

## 22.06.11

```java
static int[] temp;
    public static void sort(int[] nums) {
//将临时数组，创建出固定大小
        temp=new int[nums.length];
        sort(nums, 0, nums.length - 1);

    }
    //  区间左闭右闭
    public static void sort(int[] nums, int left, int right) {
        if (left == right) return;

        int mid = (right - left) / 2 + left;

        sort(nums, left, mid);
        sort(nums, mid + 1, right);
        merge(nums, left, right);
    }

    public static void merge(int[] nums, int left, int right) {
        for(int i=left;i<=right;i++){
            temp[i]=nums[i];
        }

//      数组双指针
        int mid=(right-left)/2+left;
        int i=left;
        int j=mid+1;
//      多重if语句的技巧，将终点提前考虑，即先写特殊情况，再写一般情况，这样，写一般情况的时候就可以直接排除特殊情况
//        易错点，i与j没有自增；
        for(int p=left;p<=right;p++){
            if(i==mid+1){
                nums[p]=temp[j++];
            }else if(j==right+1){
                nums[p]=temp[i++];
            }else if(temp[i]<temp[j]){
                nums[p]=temp[i++];
            }else{
                nums[p]=temp[j++];
            }
        }

    }
```

```java
int[] temp;
    int count;
    public int reversePairs(int[] nums) {
//        count=0;默认就被初始化为0
        sort(nums);
        return count;
    }

    public void sort(int[] nums) {
//将临时数组，创建出固定大小
        temp=new int[nums.length];
        sort(nums, 0, nums.length - 1);

    }
    //  区间左闭右闭
    public  void sort(int[] nums, int left, int right) {
        if (left == right) return;

        int mid = (right - left) / 2 + left;

        sort(nums, left, mid);
        sort(nums, mid + 1, right);
        merge(nums, left, right);
    }

    public  void merge(int[] nums, int left, int right) {
        for(int i=left;i<=right;i++){
            temp[i]=nums[i];
        }



//      数组双指针
        int mid=(right-left)/2+left;
        int end=mid+1;

//     技巧，涉及边界，一定一定要想明白区间，end是开区间，所以一开始才会没有数据，开区间适合统计区间内的数据，
//     维护 nums[mid+1..end-1] 是符合条件的元素
        for(int p=left;p<=mid;p++){
            while (end<=right&&(long)nums[p]>(long)nums[end]*2){
                end++;
            }
            count+=end-(mid+1);
        }
        int i=left;
        int j=mid+1;
//      多重if语句的技巧，将终点提前考虑，即先写特殊情况，再写一般情况，这样，写一般情况的时候就可以直接排除特殊情况
//        易错点，i与j没有自增；
        for(int p=left;p<=right;p++){
            if(i==mid+1){
                nums[p]=temp[j++];
            }else if(j==right+1){
                nums[p]=temp[i++];
            }else if(temp[i]<temp[j]){
                nums[p]=temp[i++];
            }else{
                nums[p]=temp[j++];
            }
        }

    }
```

## 22.06.12

```java
 private int[] preSum;

    public NumArray(int[] nums) {
        preSum=new int[nums.length+1];
//        区间，【0，i）
        for(int i=0;i<nums.length;i++){
            preSum[i+1]=preSum[i]+nums[i];
        }

    }
//    细节的，如果采用闭区间，【0，1】，答案为preSum[right]-preSum[left]+nums[left]
//    初始化前缀和数组，需要判断有没有越界
    public int sumRange(int left, int right) {
       return preSum[right+1]-preSum[left];

    }
```

```java
private int[][] preSum;
        public NumMatrix(int[][] matrix) {
            int m=matrix.length;
            int n=matrix[0].length;
            if(m==0||n==0)return;
            preSum =new int[m+1][n+1];
            for(int i=1;i<=m;i++){
                for(int j=1;j<=n;j++){
                    preSum[i][j]=preSum[i-1][j]+preSum[i][j-1]+matrix[i-1][j-1]-preSum[i-1][j-1];

                }
            }

        }
//        [2,1,3,4];
        public int sumRegion(int row1, int col1, int row2, int col2) {
            return preSum[row2+1][col2+1]-preSum[row1][col2+1]-preSum[row2+1][col1]+preSum[row1][col1];
        }
```

```java
  private int[] diff;

//    初始化差分数组
    public Difference(int[] nums){
//        如果表达式为false，则断言失败，则会抛出一个AssertionError对象。这个AssertionError继承于Error对象，
        assert nums.length>0;
        diff=new int[nums.length];
        diff[0]=nums[0];
        for(int i=1;i<diff.length;i++){
            diff[i]=nums[i]-nums[i-1];
        }
    }

//区间增删操作
    public void increment(int i, int j, int val) {
        diff[i] += val;
        if (j + 1 < diff.length) {
            diff[j + 1] -= val;
        }
    }
//    恢复原来数组
    public int[] result(){
        int []nums=new int[diff.length];
        nums[0]=diff[0];
        for (int i = 1; i < nums.length; i++) {
            nums[i]=nums[i-1]+diff[i];
        }
        return nums;
    }
```

```java
private int [] diff=new int[1001];
public boolean carPooling(int[][] trips, int capacity) {

    for(int i=0;i<trips.length;i++){
        increment(trips[i][1]-1,trips[i][2]-1,trips[i][0]);
    }

   int[] nums= result();
    for (int i = 0; i < nums.length; i++) {
        if(nums[i]>capacity)return false;
    }
    return true;
}
public void increment(int i, int j, int val) {
    diff[i] += val;
    if (j + 1 < diff.length) {
        diff[j + 1] -= val;
    }
}
public int[] result(){
    int []nums=new int[diff.length];
    nums[0]=diff[0];
    for (int i = 1; i < nums.length; i++) {
        nums[i]=nums[i-1]+diff[i];
    }
    return nums;
}
```

```java
private int [] diff;
public int[] corpFlightBookings(int[][] bookings, int n) {
    diff=new int[n];
    for(int i=0;i<bookings.length;i++){
        increment(bookings[i][0]-1,bookings[i][1]-1,bookings[i][2]);
    }

    return result();
}
public void increment(int i, int j, int val) {
    diff[i] += val;
    if (j + 1 < diff.length) {
        diff[j + 1] -= val;
    }
}

public int[] result(){
    int []nums=new int[diff.length];
    nums[0]=diff[0];
    for (int i = 1; i < nums.length; i++) {
        nums[i]=nums[i-1]+diff[i];
    }
    return nums;
}
```

## 22.06.13

```java
private int rank;
private int res;
public int kthSmallest(TreeNode root, int k) {
    rank = 0;
    traverse(root,k);
    return res;
}

void traverse(TreeNode root, int k) {
    if (root == null) return;
    traverse(root.left, k);

    rank++;
    if(rank==k){
        res=root.val;
    }
    traverse(root.right,k);

}
```

```java
 private int sum;
 public TreeNode convertBST(TreeNode root) {
     sum=0;
     traverse(root);
     return root;
 }
public void traverse(TreeNode root){
     if(root==null){
         return;
     }
     traverse(root.right);
     sum+=root.val;
     root.val=sum;
     traverse(root.left);
 }
```

```java
  public boolean isValidBST(TreeNode root) {

        return isValidBST(root,null,null);

    }
//    分解问题
    boolean isValidBST(TreeNode root,TreeNode left,TreeNode right){
        if(root==null)return true;
        if(left!=null&&root.val<=left.val)return false;
        if(right!=null&&root.val>=right.val)return false;
        return isValidBST(root.left,left,root)
                &&isValidBST(root.right,root,right);
    }
```

```java
public TreeNode searchBST(TreeNode root, int val) {
    if(root==null)return null;
    if(val<root.val)return searchBST(root.left,val);
    if(val>root.val)return searchBST(root.right,val);
    return root;
}
```

```java
public TreeNode insertIntoBST(TreeNode root, int val) {
    if(root==null){
        return new TreeNode(val);
    }

    if(val<root.val)root.left=insertIntoBST(root.left,val);
    if(val>root.val)root.right=insertIntoBST(root.right,val);
    return root;
}
```

```java
 public static TreeNode deleteNode(TreeNode root, int key) {
        if(root==null)return null;
        if(key==root.val){
//           找到节点分 三种情况
            if(root.left==null)return root.right;
            if(root.right==null)return root.left;
//            右子树的最小值
            TreeNode minNode=getMin(root.right);
//            细节的：必须删除当前的右节点
           root.right= deleteNode(root.right,minNode.val);
            minNode.left=root.left;
            minNode.right=root.right;
            return minNode;
        }
        if(key<root.val)root.left= deleteNode(root.left,key);
        if(key>root.val)root.right=deleteNode(root.right,key);
        return root;
    }

//   败笔,数据不可以这样修改,直接修改treeNode不可取


    public static TreeNode getMin(TreeNode root){
        while (root.left!=null)root=root.left;
        return root;
    }
```

## 22.06.14

```java
private int[][] res;

public int numTrees(int n) {
    res = new int[n + 1][n + 1];

    return count(1, n);

}

int count(int low, int high) {
    if (low > high) return 1;

    if (res[low][high] != 0) return res[low][high];
    int out = 0;
    for (int i = low; i <= high; i++) {

        out += count(low, i - 1) * count(i + 1, high);

    }
    res[low][high] = out;
    return out;
}
```
